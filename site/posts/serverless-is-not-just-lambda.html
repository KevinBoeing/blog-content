<h2>What is Serverless?</h2>

<p>Serverless means building and running applications without <i>thinking</i> about servers.</p>

<p>There are servers, of course, they’re just managed by someone else. Developers are not concerned with virtual, or physical, server machines and other infrastructure aspects such as host-level networking.</p>

<h3>Benefits</h3>

<p>Cost savings together with implicit scaling and high availability capabilities are the greatest advantages of serverless architectures:</p>

<ul>
  <li><strong>No operational overheads.</strong> Infrastructure is someone else’s concern.</li>
  <li><strong>Pay as you go.</strong> No additional cost for unused resources.</li>
  <li><strong>Scalability.</strong> Resources scale automatically based on the incoming load.</li>
  <li><strong>High availability.</strong> Serverless services are highly available by default.</li>
</ul>

<p>Moreover, serverless computing is much more <i>green</i> as no resources are kept up and running when not needed, which prevents energy wasting and saves our planet.</p>

<h3>Drawbacks</h3>

<p>Serverless comes with some disadvantages to take into account. Due to latency issues, vendor lock-in, and potential development difficulties, Serverless doesn’t fit every use-case:</p>

<ul>
  <li><strong>Latency.</strong> Not suitable for synchronously responsive communication due to cold starts.</li>
  <li><strong>Vendor lock-in.</strong> Usually no standard APIs. Partly resolvable via third-party framework which, however, introduces a product lock-in.</li>
  <li><strong>Multitenancy.</strong> Multitenancy must be solved on the application level which increases development costs.</li>
  <li><strong>Testing.</strong> Serverless systems are hard to test locally.</li>
  <li><strong>Debugging.</strong> Some common practices like remote access are not possible.</li>
  <li><strong>Complexity.</strong> Big amounts of small services make communication serverless systems complex and difficult to reason about.</li>
</ul>

<h3>Use-Cases</h3>

<p>Serverless architecture is a great fit for asynchronous, stateless applications that can be started instantaneously as well as for use cases that see infrequent, unpredictable surges in demand.</p>

<p>Typical use-cases for Serverless are:</p>

<ul>
  <li>Event-driven systems.</li>
  <li>Batch processing.</li>
  <li>Data stream processing.</li>
  <li>Scheduled tasks.</li>
  <li>Chat bots.</li>
</ul>

<h3>Serverless vs FaaS (Function as a Service)</h3>

<p>While FaaS is serverless, Serverless does not mean only FaaS. Consider the following AWS serverless services, where only AWS Lambda is a representative of FaaS:</p>

<ul>
  <li>Computation
    <ul>
      <li>Functions
        <ul>
          <li>AWS Lambda</li>
        </ul>
      </li>
      <li>Engines
        <ul>
          <li>AWS Fargate</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Databases
    <ul>
      <li>Key-Value Store
        <ul>
          <li>Amazon DynamoDB</li>
        </ul>
      </li>
      <li>Relational
        <ul>
          <li>Amazon Aurora Serverless</li>
          <li>Amazon RDS Proxy</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Messaging
    <ul>
      <li>Amazon EventBridge</li>
      <li>Amazon SNS</li>
      <li>Amazon SQS</li>
    </ul>
  </li>
  <li>Object Storages
    <ul>
      <li>Amazon S3</li>
    </ul>
  </li>
  <li>Identity Management
    <ul>
      <li>Amazon Cognito</li>
    </ul>
  </li>
  <li>Routing
    <ul>
      <li>Amazon API Gateway</li>
    </ul>
  </li>
</ul>

<p>In some literature, serverless services other than FaaS are called BaaS (Backend as a Service). Taking BaaS into the account, we can simply say that Serverless equals FaaS + BaaS.</p>

<h3>Serverless vs PaaS (Platform as a Service)</h3>

<p>Serverless is similar to PaaS, however, it goes beyond the traditional usages of containers by removing the concept of long-lived server components.</p>

<p>With PaaS (such as Cloud Foundry), developers have much low-level control of operating the application and still have to construct and scale the platform. Serverless is designed to bring entire applications up and down for individual requests automatically.</p>

<p>Another difference can be found in pricing models. While with PaaS the costs tie to reserved compute, network, and storage resources, you never pay for serverless resources that idle.</p>

<h3>Serverless vs SaaS (Software as a Service)</h3>

<p>Simply put, SaaS is about <i>using</i> applications while Serverless is about <i>building</i> them.</p>

<p>SaaS usually offers a complete business solution to use (such as Salesforce CRM, Microsoft Dynamics 365, Dropbox, etc.) with a different pricing model (user-based subscriptions).</p>

<p>Serverless offerings, however, consist of building blocks for application development such as backend services (storages, databases, etc.) and computation models (functions and container engines).</p>

<h2>AWS Lambda</h2>

<p><a href="https://aws.amazon.com/lambda/" target="_blank">Lambda</a> is a serverless compute service to run code. The code is organized into independent units called functions. Each function has well-defined inputs and outputs and it is written in a supported in one of the languages that Lambda supports. Alternatively, a custom execution container image can be assigned to the function.</p>

<p>Lambda functions provide a high-availability infrastructure including server and operating system maintenance, capacity provisioning and automatic scaling, code monitoring and logging out of the box.</p>

<p>You pay as you go based on the consumed compute time and the category of resources that are assigned to the function.</p>

<h3>AWS Fargate</h3>

<p><a href="https://aws.amazon.com/fargate/" target="_blank">AWS Fargate</a> is a serverless compute engine for containers that works with both <a href="https://aws.amazon.com/eks/" target="_blank">EKS</a> and <a href="https://aws.amazon.com/ecs/" target="_blank">ECS</a>.</p>

<ul>
  <li>No operational overhead of scaling, patching, securing, and managing servers.</li>
  <li>No over-provisioning and paying for additional servers, you only pay for the resources that you use.</li>
  <li>Workload isolation and improved security.</li>
  <li>Out-of-box observability.</li>
</ul>

<p><a href="https://docs.aws.amazon.com/eks/latest/userguide/fargate.html" target="_blank">Fargate</a> is a launch-type alternative to <a href="https://aws.amazon.com/ec2/" target="_blank">EC2</a> where provisioning and managing of the infrastructure resources (compute and memory) is fully managed by AWS.

<p>Fargate supports all of the common container use cases such as microservices architecture applications, batch processing, machine learning, etc.</p>

<p>With Fargate the <strong>applications are decoupled from the underlying hosts</strong>. As the underlying servers are abstracted away no direct iterations such as login or customization are anymore allowed.</p>

<ul>
  <li>Decoupled networking.</li>
  <li>Decoupled permissions.</li>
  <li>Decoupled monitoring.</li>
</ul>

<h3>Fargate with EKS</h3>

<p>Alongside <a href="https://docs.aws.amazon.com/eks/latest/userguide/worker.html" target="_blank">self-managed EC2 nodes</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html" target="_blank">managed node groups</a>, <a href="https://docs.aws.amazon.com/eks/latest/userguide/fargate.html" target="_blank">AWS Fargate</a> is the third option for a compute engine on the EKS scheduler. Fargate profile is an interface to configure Fargate on an EKS cluster.</p>

<p>You don’t see any virtual machines in your account when running EKS pods on Fargate — it’s completely serverless.</p>

<p>Fargate scheduler is installed on EKS as an add-on extension to the Kubernetes scheduler to schedule and run pods on Fargate.</p>

<p>Cluster scaling is fully managed by AWS, you scale only your application.</p>

<p>Load balancing can be easily done by using <a href="https://docs.aws.amazon.com/eks/latest/userguide/aws-load-balancer-controller.html" target="_blank">AWS Load Balancer Controller</a>.</p>

<h4>Limitation of running EKS on Fargate</h4>

<ul>
  <li>No privileged pods.</li>
  <li>No support for general purpose DaemonSet.</li>
  <li>No GPUs.</li>
  <li>No Amazon EBS support (only Amazon EFS).</li>
  <li>Run only in private subnets.</li>
</ul>

<h3>Amazon Aurora Serverless</h3>

<p>Amazon Aurora Serverless is an on-demand, auto-scaling configuration for <a href="https://aws.amazon.com/rds/aurora/" target="_blank">Amazon Aurora</a>, MySQL, and PostgreSQL-compatible relational databases.</p>

<p>Serverless Aurora scales automatically up and down, starts up, and shuts down based on your application’s demands.</p>

<ul>
  <li>Scale instantly, from hundreds to hundreds of thousands of transactions, within a second.</li>
  <li>Adjusts capacity in fine-grained increments based on the application’s needs.</li>
  <li>You pay only for the capacity you use on a per-second basis.</li>
  <li>Supports the full breadth of Aurora features (highly durable, fault-tolerant, self-healing, continuous backup, etc.).</li>
  <li>High-available by default.</li>
</ul>

<p>Serverless Aurora has typical use-cases of serverless databases:</p>

<ul>
  <li>Unpredictable and variable workloads.</li>
  <li>Enterprise database fleet management.</li>
  <li>Scaled-out databases split across multiple servers.</li>
</ul>

<p>For instance, if you run a test environment where testing is performed a few times a day and nothing is going on during the night, Serverless Aurora will definitely save you a couple of bucks...</p>

