<p>We already met AssemblyScript in the <a href="/learning-webassembly-8-compiling-into-wasm">previous part</a> of this <a href="/learning-webassembly-series">series</a>. We created a simple program and got an impression of what programming in AssemblyScript feels like. In this part, we will go deeper into the concepts and basics of the language.</p>

<h2>Gettings Started</h2>

<p><a href="https://www.assemblyscript.org" target="_blank">AssemblyScript</a> compiles a strict variant of <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> to WebAssembly using <a href="https://github.com/WebAssembly/binaryen" target="_blank">Binaryen</a> compiler and toolchain infrastructure library.</p>

<p>We will use <a href="https://www.npmjs.com" target="_blank">npm</a> to initialize our first AssemblyScript project:</p>

<pre>
$ npm init -y
</pre>

<p>AssemblyScript provides a very lightweight and efficient <a href="https://www.assemblyscript.org/loader.html" target="_blank">loader</a> of Wasm modules. Besides loading Wasm modules and exposing them via WebAssembly API, the loader is also providing utilities to allocate and read strings, arrays, and classes.</p>

<pre>
$ npm install --save @assemblyscript/loader
</pre>

<p>To compile AssemblyScript into Wasm we need to install the <code>asc</code> <a href="https://www.assemblyscript.org/compiler.html" target="_blank">compiler</a> as a dev dependency:</p>

<pre>
$ npm install --save-dev assemblyscript
</pre>

<p>Once installed, the compiler provides a handy scaffolding utility to quickly set up a new project:</p>

<pre>
$ npx asinit .
</pre>

<p>We will be modifying two files from the generated project:</p>

<dl>
  <dt><em>index.js</em></dt>
  <dd>The main file for loading and working with Wasm modules.</dd>
  <dt><em>assembly/index.ts</em></dt>
  <dd>AssemblyScript source file to be compiled into Wasm.</dd>
  <dt><em>tests/index.js</em></dt>
  <dd>Test suite for the main file.</dd>
</dl>

<h2>Exports and Imports</h2>

<p>Let us create our first AssemblyScript function in <em>assembly/index.ts</em>:</p>

<pre class="brush: javascript">
export function main(): void {
  print(42);
}
</pre>

<p>Unfortunately, we don’t get the function <code>print</code> for free. Leaving <a href="/learning-webassembly-7-introducing-wasi">WASI</a> aside, interactions between Wasm modules and operating system must be provided by the glue code, JavaScript in our case. We have to declare the function signature first:</p>

<pre class="brush: javascript">
declare function print(n: i32): void;
</pre>

<p>Then, we can import a custom implementation in the main JavaScript file <em>index.js</em>:</p>

<pre class="brush: javascript">
var imports = {
  "index": {
    print: console.log
  }
};
</pre>

<p>The <code>imports</code> object is used by the initialization of the Wasm module by the loader:</p>

<pre class="brush: javascript">
var fs = require("fs");
var loader = require("@assemblyscript/loader");

var imports = {
  "index": {
    print: console.log
  }
};

var wasm = loader.instantiateSync(
  fs.readFileSync("./build/optimized.wasm"),
  imports);

wasm.exports.main();
</pre>

<p>Before we can run this code, first, we must compile our Wasm module:</p>

<pre>
$ npm run asbuild
</pre>

<p>This convenient script runs the asc compiler and generates untouched debug and optimized release Wasm files into the <em>build</em> directory. Now, we can simply run it:</p>

<pre>
$ node index.js
42
</pre>

<p>Eureka, we have just created our first working Wasm program in AssemblyScript!</p>

<h2>Strings, Strings, Strings!</h2>

<p>Don’t get too excited, but there is one thing I have to share with you: AssemblyScript extends the set of Wasm standard data types for <em><a href="https://www.assemblyscript.org/stdlib/string.html" target="_blank">strings</a></em>.</p>

<pre class="brush: javascript">
export function hello(
    name: string): string {

  return "Hello, " + name + "!";
}
</pre>

<p>We can import and export strings from JavaScript with a little help from the loader:</p>

<pre class="brush: javascript">
var { hello,
  __newString,
  __getString } = wasm.exports;
</pre>

<p>In order to use exporting operating, the module must be compiled with the <code>--exportRuntime</code> flag:</p>

<pre>
$ npm run asbuild:optimized -- --exportRuntime
</pre>

<p>The loaded module contains functions for allocating and retaining strings in Wasm memory:</p>

<pre class="brush: javascript">
// allocate string in memory
var pti = __newString("Tomas");

var pto = hello(pti);

// retain string from memory
var str = __getString(pto);
</pre>

<p>Finally, we have an ordinary JavaScript string object:</p>

<pre class="brush: javascript">
console.log(str);
</pre>

<p>It works as expected:</p>

<pre>
$ node index.js
Hello, Tomas!
</pre>

<h2>Memory</h2>

<p>Wasm uses linear memory stored in a specific memory offset isolated from other programs.</p>

<p><a href="https://www.assemblyscript.org/memory.html" target="_blank">In AssemblyScript</a>, there is static memory for static data known at the compilation time and dynamic memory (heap) managed by the runtime. Programs access chunks of memory via pointers. Dynamic memory is tracked by the runtime’s garbage collector and reused when not needed by the program anymore.</p>

<p>We have already seen allocating memory via <code>__newString</code> loader function. <code>__newString</code> is a convenience variant of the more general function <code>__new</code> for allocating managed objects.</p>

<p>We can achieve the same functionality of <code>__newString</code> with some boiler-plate code:</p>

<pre class="brush: javascript">
var { hello, memory,
  __new, __pin, __unpin } = wasm.exports;

var input = "Tomas";
var length = input.length;

// allocate memory (usize, String (id=1))
var pt = __new(length << 1, 1);

// load bytes into memory
var ibytes = new Uint16Array(memory.buffer);
for (let i = 0, p = pt >>> 1; i < length; ++i)
  ibytes[p + i] = input.charCodeAt(i);

// pin object
var pti = __pin(pt);

// call wasm
var pto = __pin(hello(pti));

// retrieve string size
var SIZE_OFFSET = -4;
var olength = new Uint32Array(memory.buffer)[pto + SIZE_OFFSET >>> 2];

// load string from memory
var obytes = new Uint8Array(memory.buffer, pto, olength);
var str = new TextDecoder('utf8').decode(obytes);

// unpin objects for GC
__unpin(pti);
__unpin(pto);

console.log(str);
</pre>

<p>Function <code>__pin</code> pins the object externally so it does not become <a href="https://www.assemblyscript.org/garbage-collection.html" target="_blank">garbage collected</a>.</p>

<p>As we can see, strings in AssemblyScript are nothing more than arrays of integers stored in memory. The language brings some convenient syntax and utilities, however, internally, it does work with the <a href="/learning-webassembly-4-wasm-memory-and-working-with-strings" target="_blank">same old</a> Wasm mechanism.</p>

<h2>Arrays</h2>

<p>AssemblyScript provides convenient functions not only for strings, but we can also work with all kinds of <em><a href="https://www.assemblyscript.org/stdlib/array.html" target="_blank">arrays</a></em>.</p>

<p>As an example, consider a function that takes an array of 32-bit integers and returns a new array where all elements are multiplied by a scalar. In AssemblyScript, it would look like this:</p>

<pre class="brush: javascript">
export function multiply(
    matrix: Int32Array, x: i32): Int32Array {

  var arr = new Int32Array(matrix.length);
  for (var i = 0; i < matrix.length; i++) {
    arr[i] = matrix[i] * x;
  }
  return arr;
}
</pre>

<p>To work with arrays properly, we need a unique class identifier for <code>Int32Array</code>. We can export it from AssemblyScript:</p>

<pre class="brush: javascript">
export const Int32Array_ID =
    idof&lt;Int32Array&gt;();
</pre>

<p>In JavaScript, we can create an input array and read the result with appropriate utility functions:</p>

<pre class="brush: javascript">
var { multiply, Int32Array_ID,
  __newArray, __getArray } = wasm.exports;

// input array
var input = [1, 2, 3];
var ai = __newArray(Int32Array_ID, input));

// call wasm, output array
var ao = __getArray(multiply(arri, 2));

console.log(ao);
</pre>

<p>Function <code>__getArray</code> copies the array's values so it does not have to be pinned.</p>

<p>The result should be no surprise:</p>

<pre>
$ node index.js
[ 2, 4, 6 ]
</pre>

<h2>Testing AssemblyScript</h2>

<p>After initializing a new AssemblyScript project, you can find a basic test in <em>test/index.js</em>. Basically, we can test everything which we export from the main JavaScript file:</p>

<pre class="brush: javascript">
// index.js

// ...

module.exports = wasm.exports;
</pre>

<pre class="brush: javascript">
// test/index.js

var assert = require("assert");
var wasm = require("..");

var pti = wasm.__newString("Test");
var pto = hello(pti);
var str = wasm.__getString(pto);

assert.equal(str, "Hello, Test!");
</pre>

<p>Testing as such looks pretty tedious. We can hide the JavaScript glue behind a facade function and test that instead of the “naked” Wasm function:</p>

<pre class="brush: javascript">
// index.js

// ...

function sayHello(name) {
  var pti = __newString(name);
  var pto = hello(pti);
  var str = __getString(pto);

  return str;
}

module.exports = { sayHello };
</pre>

<pre class="brush: javascript">
// test/index.js

const assert = require("assert");
const index = require("..");

assert.equal(
    index.sayHello("Test"),
    "Hello, Test!"
);
</pre>

<p>Run it simply with npm:</p>

<pre>
$ npm test
</pre>

<h2>Further Steps</h2>

<p>We have learned the basics of programming in AssemblyScript, including utilities for working with memory, strings and arrays, and we have written our first unit test.</p>

<p>In the <a href="/learning-webassembly-10-image-processing-in-assemblyscript">next part</a> of this <a href="/learning-webassembly-series">series</a> we will go deeper into programming in AssemblyScript and learn how to generate some graphics.</p>

<p>Stay tuned!</p>

